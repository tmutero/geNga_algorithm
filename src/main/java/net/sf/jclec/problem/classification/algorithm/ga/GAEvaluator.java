package net.sf.jclec.problem.classification.algorithm.ga;

import java.util.Comparator;

import net.sf.jclec.IConfigure;
import net.sf.jclec.IFitness;
import net.sf.jclec.IIndividual;
import net.sf.jclec.base.AbstractParallelEvaluator;
import net.sf.jclec.fitness.SimpleValueFitness;
import net.sf.jclec.fitness.ValueFitnessComparator;
import net.sf.jclec.problem.classification.base.Rule;
import net.sf.jclec.problem.classification.syntaxtree.SyntaxTreeRuleIndividual;
import net.sf.jclec.problem.util.dataset.IDataset;
import net.sf.jclec.problem.util.dataset.instance.IInstance;
import net.sf.jclec.problem.util.dataset.metadata.IMetadata;

import org.apache.commons.configuration.Configuration;

/**
 * Evaluator for Tan et al. 2002 - Mining multiple comprehensible classification rules using genetic programming<p/>
 * 
 * The fitness function evaluates the confusion matrix for the data class of the current algorithm' execution.
 * Sensitivity and specificity are evaluated and weighted to build the fitness measure for the individual.
 * The weights allows for defining the importance of sensitivity and specificity for each data problem, i.e., cost-sensitive learning.
 * 
 */

public class TanEvaluator extends AbstractParallelEvaluator implements IConfigure
{
	/////////////////////////////////////////////////////////////////
	//--------------------------------------- Serialization constant
	/////////////////////////////////////////////////////////////////

	/** Generated by Eclipse */

	private static final long serialVersionUID = 3613350191235561000L;

	// ///////////////////////////////////////////////////////////////
	// --------------------------------------------------- Properties
	// ///////////////////////////////////////////////////////////////
	
	/** Train Dataset */

	protected IDataset dataset;

	/** Maximize the fitness function */

	private boolean maximize = true;

	/** Classified class */

	protected int classifiedClass;
	
	/** Parameters to take into the simplicity of the rule */	

	protected double w1, w2;

	/** Fitness comparator */

	protected transient ValueFitnessComparator comparator = new ValueFitnessComparator(!maximize);

	// ///////////////////////////////////////////////////////////////
	// ------------------------------------------------- Constructors
	// ///////////////////////////////////////////////////////////////

	/**
	 * Empty constructor.
	 */

	public TanEvaluator() {
		super();
	}

	// ///////////////////////////////////////////////////////////////
	// ------------------------------------------------ Public methods
	// ///////////////////////////////////////////////////////////////

	/**
	 * Get the dataset 
	 * 
	 * @return dataset
	 */
	
	public IDataset getDataset()
	{
		return this.dataset;
	}
	
	/**
	 * Set the dataset
	 * 
	 * @param dataset the dataset
	 */
	
	public void setDataset(IDataset dataset)
	{
		this.dataset = dataset;
	}
	
	/**
	 * Get the W1 parameter
	 * 
	 * @return W1 value
	 */
	
	public double getW1() {
		return w1;
	}

	/**
	 * Set the W1 parameter
	 * 
	 * @param w1 value
	 */
	
	public void setW1(double w1) {
		this.w1 = w1;
	}

	/**
	 * Get the W2 parameter
	 * 
	 * @return W2 value
	 */
	public double getW2() {
		return w2;
	}

	/**
	 * Set the W2 parameter
	 * 
	 * @param w2 value
	 */	
	public void setW2(double w2) {
		this.w2 = w2;
	}

	/**
	 * Set the actual class to be classified
	 * 
	 * @param classifiedClass the class to be classified
	 */
	public void setClassifiedClass(int classifiedClass) {
		this.classifiedClass = classifiedClass;
	}

	/**
	 * Get the actual class to be classified
	 * 
	 * @return the class to be classified
	 */
	public int getClassifiedClass() {
		return classifiedClass;
	}
	
	/////////////////////////////////////////////////////////////////
	// ------------------------------ Implementing IConfigure methods
	/////////////////////////////////////////////////////////////////
	
	/**
	 * Configuration method
	 * 
	 * @param settings Configuration settings
	 */
	
	public void configure(Configuration settings)
	{
		float w1 = settings.getFloat("w1", 0.7f);
		setW1(w1);

		float w2 = settings.getFloat("w2", 0.8f);
		setW2(w2);
	}

	// ///////////////////////////////////////////////////////////////
	// ------------------------ Overwriting AbstractEvaluator methods
	// ///////////////////////////////////////////////////////////////

	/**
	 * Evaluates the individual and compute it fitness 
	 * 
	 * @param individual Individual to evaluate
	 */

	protected void evaluate(IIndividual individual) 
	{
		Rule rule = (Rule) ((SyntaxTreeRuleIndividual) individual).getPhenotype();
		
		int tp = 0, fp = 0, tn = 0, fn = 0;
				
		IMetadata metadata = getDataset().getMetadata();
		
		//Calculate the confusion matrix
		for(IInstance instance : dataset.getInstances())
		{
			double value = instance.getValue(metadata.getClassIndex());
			
			if((Boolean) rule.covers(instance))
			{		
				if (value == classifiedClass)
					tp++;
				else
					fp++;
			}
			else
			{
				if (value != classifiedClass)
					tn++;
				else
					fn++;
			}
		}
		
		double fitness;
		double se, sp;
		
	   	if(tp + fn == 0)
			se = 1;
		else
			se = (double) tp / (tp + w1*fn);

		if(tn + fp == 0)
			sp = 1;
		else
			sp = (double) tn / (tn + w2*fp);

	    // Set the fitness to the individual
		fitness = se * sp;
		
		individual.setFitness(new SimpleValueFitness(fitness));
	}

	/**
	 * {@inheritDoc}
	 */
	
	public Comparator<IFitness> getComparator() 
	{		
		return comparator;
	}	
}