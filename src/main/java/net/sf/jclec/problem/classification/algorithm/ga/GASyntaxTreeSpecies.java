package net.sf.jclec.problem.classification.algorithm.ga;

import java.util.ArrayList;
import java.util.List;

import net.sf.jclec.problem.classification.blocks.And;
import net.sf.jclec.problem.classification.blocks.Equal;
import net.sf.jclec.problem.classification.blocks.Greater;
import net.sf.jclec.problem.classification.blocks.GreaterOrEqual;
import net.sf.jclec.problem.classification.blocks.In;
import net.sf.jclec.problem.classification.blocks.Less;
import net.sf.jclec.problem.classification.blocks.LessOrEqual;
import net.sf.jclec.problem.classification.blocks.Not;
import net.sf.jclec.problem.classification.blocks.NotEqual;
import net.sf.jclec.problem.classification.blocks.Out;
import net.sf.jclec.problem.classification.crisprule.CrispRule;
import net.sf.jclec.problem.classification.syntaxtree.SyntaxTreeRuleIndividual;
import net.sf.jclec.problem.classification.syntaxtree.SyntaxTreeSpecies;
import net.sf.jclec.problem.util.dataset.attribute.IAttribute;
import net.sf.jclec.syntaxtree.NonTerminalNode;
import net.sf.jclec.syntaxtree.SyntaxTree;
import net.sf.jclec.syntaxtree.TerminalNode;

/**
 * Species for Tan et al. 2002 - Mining multiple comprehensible classification rules using genetic programming<p/>
 * 
 * Defines the grammar, the production rules, the terminal and non-terminal symbols to generate the classification rules.
 * 
 * Main methods:
 *   setTerminalSymbols() defines the terminal symbols (functions, operators and input attributes).
 *   setNonTerminalSymbols() defines the grammar and the production rules.
 * 
 */

public class GASyntaxTreeSpecies extends SyntaxTreeSpecies
{
	/////////////////////////////////////////////////////////////////
	// --------------------------------------- Serialization constant
	/////////////////////////////////////////////////////////////////
	
	/** Generated by Eclipse */

	private static final long serialVersionUID = 1L;

	/////////////////////////////////////////////////////////////////
	// ------------------------------------------------- Constructors
	/////////////////////////////////////////////////////////////////

	/**
	 * Default (empty) constructor
	 */
	 
	public GASyntaxTreeSpecies(){
		super();
	}
	
	/////////////////////////////////////////////////////////////////
	// -------------------------------------------- Protected methods
	/////////////////////////////////////////////////////////////////
	
	/**
	 * Establishes the terminal symbols
	 * 
	 * @param inputAttributes list of input attributes
	 * @return list of terminal symbols
	 */
	
	protected List<TerminalNode> setTerminalSymbols(List<IAttribute> inputAttributes)
	{
		List<TerminalNode> terminals = super.setTerminalSymbols(inputAttributes);
		
		//Set fixed terminal symbol 
		if(existCategoricalAttributes){
			terminals.add(new TerminalNode("=", new Equal()));
			terminals.add(new TerminalNode("!=", new NotEqual()));
		}
		if(existNumericalAttributes){
			terminals.add(new TerminalNode(">=", new GreaterOrEqual()));
			terminals.add(new TerminalNode(">", new Greater()));
			terminals.add(new TerminalNode("<=", new LessOrEqual()));
			terminals.add(new TerminalNode("<", new Less()));
			terminals.add(new TerminalNode("IN", new In()));
			terminals.add(new TerminalNode("OUT", new Out()));
		}
		
		//Set fixed boolean operators
		terminals.add(new TerminalNode("AND", new And()));
		terminals.add(new TerminalNode("NOT", new Not()));
		
		return terminals;
	}
	
	/**
	 * Establishes the nonterminal symbols
	 * 
	 * @param inputAttributes list of input attributes
	 * @return list of nonterminal symbols
	 */
	
	protected List<NonTerminalNode> setNonTerminalSymbols(List<IAttribute> inputAttributes)
	{
		List<NonTerminalNode> nonTerminals = new ArrayList<NonTerminalNode>();
		
		// Number of input attribute
		int numAttributes = inputAttributes.size();
		
		//Set fixed non terminal symbols		
		nonTerminals.add(new NonTerminalNode("antecedent", new String [] {"comparison"}));
		nonTerminals.add(new NonTerminalNode("antecedent", new String [] {"AND", "antecedent", "comparison"}));
		nonTerminals.add(new NonTerminalNode("antecedent", new String [] {"NOT", "antecedent"}));
		
		if(existCategoricalAttributes) 
		{
			nonTerminals.add(new NonTerminalNode("comparison", new String [] {"categorical_comparator", "categorical_attribute_comparison"}));
			nonTerminals.add(new NonTerminalNode("categorical_comparator", new String [] {"="}));
			nonTerminals.add(new NonTerminalNode("categorical_comparator", new String [] {"!="}));
		}
		if(existNumericalAttributes) 
		{
			nonTerminals.add(new NonTerminalNode("comparison", new String [] {"numerical_comparator", "numerical_attribute_comparison"}));
			nonTerminals.add(new NonTerminalNode("numerical_comparator", new String [] {">="}));
			nonTerminals.add(new NonTerminalNode("numerical_comparator", new String [] {">"}));
			nonTerminals.add(new NonTerminalNode("numerical_comparator", new String [] {"<="}));
			nonTerminals.add(new NonTerminalNode("numerical_comparator", new String [] {"<"}));
			nonTerminals.add(new NonTerminalNode("comparison", new String [] {"numerical_interval_comparator", "numerical_attribute_interval_comparison"}));
			nonTerminals.add(new NonTerminalNode("numerical_interval_comparator", new String [] {"IN"}));
			nonTerminals.add(new NonTerminalNode("numerical_interval_comparator", new String [] {"OUT"}));
		}
		
		// Set non terminal symbols
		for(int i =0 ; i<numAttributes; i++){
			
			IAttribute attribute = inputAttributes.get(i);
			String [] attr = new String [] {attribute.getName(), "values"+attribute.getName()};
			String [] attrInterval = new String [] {attribute.getName(), "values"+attribute.getName(), "values"+attribute.getName()};
			
			switch(attribute.getType())
			{
				case Numerical:
					nonTerminals.add(new NonTerminalNode("numerical_attribute_comparison", attr));
					nonTerminals.add(new NonTerminalNode("numerical_attribute_interval_comparison", attrInterval));
					break;
				case Integer:
					nonTerminals.add(new NonTerminalNode("numerical_attribute_comparison", attr));
					nonTerminals.add(new NonTerminalNode("numerical_attribute_interval_comparison", attrInterval));
					break;
				case Categorical:
					nonTerminals.add(new NonTerminalNode("categorical_attribute_comparison", attr));
					break;
			}
		}
		
		return nonTerminals;
	}
	
	@Override
	public SyntaxTreeRuleIndividual createIndividual(SyntaxTree genotype) {
		return new SyntaxTreeRuleIndividual(genotype, new CrispRule(genotype.getExprTree()));
	}
}