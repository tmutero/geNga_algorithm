package net.sf.jclec.problem.classification.algorithm.tan;

import java.util.ArrayList;
import java.util.List;

import net.sf.jclec.problem.classification.base.Rule;
import net.sf.jclec.problem.classification.crisprule.CrispRuleBase;
import net.sf.jclec.problem.util.dataset.IDataset;
import net.sf.jclec.problem.util.dataset.instance.IInstance;

/**
 * Classifier for Tan et al. 2002 - Mining multiple comprehensible classification rules using genetic programming<p/>
 * 
 * The Tan et al. algorithm states that the rules within the classifier must be sorted according to their specificity value.
 * This procedure is carried out in the sortClassifier() method.
 * 
 */

public class TanClassifier extends CrispRuleBase 
{
	/////////////////////////////////////////////////////////////////
	// --------------------------------------- Serialization constant
	/////////////////////////////////////////////////////////////////

	/** Generated by Eclipse */
	
	private static final long serialVersionUID = -6792167360656990171L;
	
	/////////////////////////////////////////////////////////////////
	// -------------------------------------------------- Constructor
	/////////////////////////////////////////////////////////////////
	
	/**
	 * Default (empty) constructor
	 */
	
	public TanClassifier()
	{
		super();
	}
	
	/////////////////////////////////////////////////////////////////
	// ----------------------------------------------- Public methods
	/////////////////////////////////////////////////////////////////
	
	/**
	 * Sort the rules based on the sensitivity
	 * 
	 * @param dataset the dataset
	 */
	
	public void sortClassifier(IDataset dataset)
	{		
		int[] tp, fp, tn, fn;

		int numRules = getClassificationRules().size();
		tp = new int[numRules];
		tn = new int[numRules];
		fn = new int[numRules];
		fp = new int[numRules];
		
		// Calculates the confusion matrix for each rule
		for(IInstance instance : dataset.getInstances())
		{
			double value = instance.getValue(dataset.getMetadata().getClassIndex());
			
			for (int i = 0; i < numRules; i++)
			{
				if ((Boolean) getClassificationRules().get(i).covers(instance))
				{
					if (getClassificationRules().get(i).getConsequent() == value)
						tp[i]++;
					else
						fp[i]++;
				}
				else
				{
					if (getClassificationRules().get(i).getConsequent() != value)
						tn[i]++;
					else
						fn[i]++;
				}
			}
		}
	
		// Calculates the sensitivity for each rule
		double[] se = new double[numRules];

		for (int i = 0; i < numRules; i++) 
		{
			if (tn[i] + fp[i] == 0)
				se[i] = 0;
			else
				se[i] = tn[i] / (double)(tn[i] + fp[i]);
		}
		
		List<Rule> rulesAux = new ArrayList<Rule>();
		
		for(int j = 0; j < numRules; j++)
		{
			double maxSe = 0;
			int maxSeRule = 0;
			
			for(int i = 0; i < numRules; i++)
			{
				if(!rulesAux.contains(getClassificationRule(i)))
				{
					if(se[i] >= maxSe)
					{
						maxSe = se[i];
						maxSeRule = i;
					}
				}
			}
			
			rulesAux.add(getClassificationRule(maxSeRule));
		}
		 
		getClassificationRules().clear();
		setClassificationRules(rulesAux);
	}
}