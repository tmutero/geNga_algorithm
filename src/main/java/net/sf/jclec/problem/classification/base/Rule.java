package net.sf.jclec.problem.classification.base;

import java.util.ArrayList;

import net.sf.jclec.IFitness;
import net.sf.jclec.exprtree.ExprTree;
import net.sf.jclec.exprtree.fun.ExprTreeFunction;
import net.sf.jclec.problem.classification.IClassifier;
import net.sf.jclec.problem.util.dataset.IDataset;
import net.sf.jclec.problem.util.dataset.instance.IInstance;
import net.sf.jclec.problem.util.dataset.metadata.IMetadata;

/**
 * Classification rule.<p/>
 * 
 * Abstract class that defines a classification rule with an exprTree as the antecedent and a class as the consequent.
 * The rule also keeps the fitness in case it is required beyond the evolutionary process. 
 * 
 * Main methods:
 *    The classify() method classifies a complete dataset and returns the class predictions for all the instances. 
 *    The covers() method checks whether the antecedent of the rule covers or not a particular instance.
 *    The getConfusionMatrix() method classifies a dataset and returns the confusion matrix.
 * 
 */

public abstract class Rule extends ExprTreeFunction implements IClassifier
{
	/////////////////////////////////////////////////////////////////
	// --------------------------------------- Serialization constant
	/////////////////////////////////////////////////////////////////

	/** Generated by Eclipse */
	
	private static final long serialVersionUID = -8174242256644010121L;

	/////////////////////////////////////////////////////////////////
	// --------------------------------------------------- Properties
	/////////////////////////////////////////////////////////////////

	/** Rule consequent */
	
	protected double consequent = -1;
	
	/** Rule fitness */
	
	protected IFitness fitness;
	
	/** Actual instance for the rule */

	private IInstance actualInstance;
		
	/////////////////////////////////////////////////////////////////
	// ------------------------------------------------- Constructors
	/////////////////////////////////////////////////////////////////
	
	/**
	 * Empty constructor.
	 */
	
	public Rule()
	{
		super();
	}
	
	public Rule(ExprTree antecedent)
	{
		super();
		setAntecedent(antecedent);
	}
	
	/////////////////////////////////////////////////////////////////
	// ----------------------------------------------- Public methods
	/////////////////////////////////////////////////////////////////
	
	/** 
	 *  Access to the rule antecedent
	 *  
	 *  @return the antecedent of the rule
	 */
	
	public ExprTree getAntecedent() 
	{
		return this.code;
	}
	
	/** 
	 *  Sets rule antecedent
	 *  
	 *  @param antecedent rule antecedent
	 */
	
	public void setAntecedent(ExprTree antecedent) 
	{
		this.code = antecedent;
	}
	
	/** 
	 *  Access to rule consequent
	 *  
	 *  @return rule consequent
	 */
	
	public double getConsequent() 
	{
		return consequent;
	}
	
	/** 
	 *  Sets rule consequent
	 *  
	 *  @param consequent rule consequent
	 */

	public void setConsequent(double consequent) 
	{
		this.consequent = consequent;
	}
	
	/** 
	 *  Set the rule fitness
	 *  
	 *  @param fitness the fitness of the rule
	 */
	
	public void setFitness(IFitness fitness) 
	{
		this.fitness = fitness;
	}
	
	/** 
	 *  Access to the rule fitness
	 *  
	 *  @return the fitness of the rule
	 */
	
	public IFitness getFitness() 
	{
		return fitness;
	}
	
	/**
	 * Gets the actual instance for evaluating the rule
	 * 
	 * @return the actualInstance
	 */
	
	public IInstance getActualInstance() {
		return actualInstance;
	}
	
	/** 
	 *  Sets the actual instance for evaluating the rule
	 *  
	 *  @param instance the instance
	 */
	
	public void setActualInstance(IInstance instance) {
		this.actualInstance = instance;
	}
	
	/** 
	 *  Classifies all the instances within the data set
	 *  
	 *  @param dataset the dataset
	 *  @return array of class predictions
	 */
	
	@Override
	public double[] classify(IDataset dataset)
	{
		ArrayList<IInstance> instances = dataset.getInstances();
		double[] predicted = new double[instances.size()];
		
		for(int i = 0; i < instances.size(); i++)
			predicted[i] = classify(instances.get(i));
		
		return predicted;
	}
	
	/** 
	 *  Checks if the rule covers an instance
	 *  
	 *  @param instance the instance
	 *  
	 *  @return true or false
	 */

	public Object covers(IInstance instance)
	{
		// Set actual instance
		setActualInstance(instance);
		// Execute code, using this as context
		return super.<Object>execute(this);
	}

	/** 
	 *  Shows the complete rule antecedent and consequent
	 *  
	 *  @return the rule
	 */
	
	public abstract String toString(IMetadata metadata);

	/**
     * Obtain the number of conditions of the rule
     * 
     * @return number of conditions
     */

	public abstract int getConditions();
	
	/**
	 * Obtains the confusion matrix for a dataset
	 * @param dataset the dataset
	 * @return the confusion matrix
	 */
	
	public int[][] getConfusionMatrix(IDataset dataset)
	{
		IMetadata metadata = dataset.getMetadata();
		ArrayList<IInstance> instances = dataset.getInstances();
		int [][] confusionMatrix = new int[metadata.numberOfClasses()][metadata.numberOfClasses()];
		
		double [] predicted = classify(dataset);
		
		for(int i = 0; i < instances.size(); i++) 
    	{
			confusionMatrix[(int) instances.get(i).getValue(metadata.getClassIndex())][(int) predicted[i]]++;
    	}
		
		return confusionMatrix;
	}
	
	public abstract Rule copy();
	
	/////////////////////////////////////////////////////////////////
	// ------------------------- Overwriting java.lang.Object methods
	/////////////////////////////////////////////////////////////////
	
	@Override
	public boolean equals(Object other)
	{
		if(getAntecedent().equals(((Rule) other).getAntecedent()))
			return true;
		else
			return false;
	}
}